struct SceneLight {
    float4 color;
    float4 position;
    float4 direction;
};

void main(
    float4 vPosition : POSITION,
    float3 vViewPos : TEXCOORD1,
    float3 vNormal : TEXCOORD2,
    float2 vTexCoord : TEXCOORD3,

    uniform SceneLight uLights[3] : BUFFER[0],
    uniform int uLightCount : BUFFER[0],
    uniform float uShininess,
    uniform float4 uColor,
    uniform int uUseTexture,
    uniform sampler2D uTexture,

    out float4 outColor : COLOR
) {
    float3 diffuse = float3(0.0, 0.0, 0.0);
    float3 specular = float3(0.0, 0.0, 0.0);
    float3 normal = normalize(vNormal);

    for (int i = 0; i < uLightCount; ++i) {
        float3 lightColor = uLights[i].color.rgb;

        // ambient
        if (uLights[i].position.w == 0.0 && uLights[i].direction.w == 0.0) {
            diffuse += lightColor;
            continue;
        }

        // directional
        float3 lightVec;
        if (uLights[i].direction.w == 1.0) {
            lightVec = -normalize(uLights[i].direction.xyz);
        } else { // point
            lightVec = normalize(uLights[i].position.xyz - vViewPos);
        }

        float dotNL = max(dot(normal, lightVec), 0.0);
        if (dotNL > 0.0) {
            // Diffuse contribution
            diffuse += dotNL * lightColor;

            // Specular
            if (uShininess > 0.0) {
                float3 viewVec = normalize(-vViewPos); // Assuming camera at origin
                float3 halfVec = normalize(lightVec + viewVec);
                float dotNH = max(dot(normal, halfVec), 0.0);
                float spec = pow(dotNH, uShininess);
                specular += spec * lightColor;
            }
        }
    }

    outColor = uColor;
    outColor.rgb = clamp(diffuse * uColor.rgb + specular, 0.0, 1.0);
    if (uUseTexture != 0) {
        float4 texel = tex2D(uTexture, vTexCoord);
        outColor.rgb *= texel.rgb;
        outColor.rgb = clamp(outColor.rgb, 0.0, 1.0);
    }
}